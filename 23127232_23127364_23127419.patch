diff -ruN xv6-labs-2024-original/.git/COMMIT_EDITMSG xv6-labs-2024/.git/COMMIT_EDITMSG
--- xv6-labs-2024-original/.git/COMMIT_EDITMSG	1970-01-01 00:00:00.000000000 +0000
+++ xv6-labs-2024/.git/COMMIT_EDITMSG	2025-03-05 05:03:18.027628074 +0000
@@ -0,0 +1 @@
+Upload patch file
diff -ruN xv6-labs-2024-original/.git/HEAD xv6-labs-2024/.git/HEAD
--- xv6-labs-2024-original/.git/HEAD	2025-03-05 04:50:37.509724875 +0000
+++ xv6-labs-2024/.git/HEAD	2025-03-05 05:00:54.635630911 +0000
@@ -1 +1 @@
-ref: refs/heads/util
+ref: refs/heads/submit-patch
diff -ruN xv6-labs-2024-original/.git/config xv6-labs-2024/.git/config
--- xv6-labs-2024-original/.git/config	2025-03-05 04:50:37.509724875 +0000
+++ xv6-labs-2024/.git/config	2025-03-05 05:00:54.696012536 +0000
@@ -4,8 +4,12 @@
 	bare = false
 	logallrefupdates = true
 [remote "origin"]
-	url = git://g.csail.mit.edu/xv6-labs-2024
+	url = https://github.com/pepemoe2/Xv6-and-Unix-utilities.git
 	fetch = +refs/heads/*:refs/remotes/origin/*
-[branch "util"]
+[branch "main"]
 	remote = origin
-	merge = refs/heads/util
+	merge = refs/heads/main
+	vscode-merge-base = origin/main
+	vscode-merge-base = origin/main
+[branch "submit-patch"]
+	vscode-merge-base = origin/main
Binary files xv6-labs-2024-original/.git/index and xv6-labs-2024/.git/index differ
diff -ruN xv6-labs-2024-original/.git/logs/HEAD xv6-labs-2024/.git/logs/HEAD
--- xv6-labs-2024-original/.git/logs/HEAD	2025-03-05 04:50:37.509724875 +0000
+++ xv6-labs-2024/.git/logs/HEAD	2025-03-05 05:03:18.027628074 +0000
@@ -1 +1,3 @@
-0000000000000000000000000000000000000000 79e8024d61c3dd92ccf064fc67bb99cb999f70ab hieu <dangthanhhieu2005@gmail.com> 1741150237 +0000	clone: from git://g.csail.mit.edu/xv6-labs-2024
+0000000000000000000000000000000000000000 10850c6a4bbfcc72eedf474c0138a624817b6748 hieu <dangthanhhieu2005@gmail.com> 1741148316 +0000	clone: from https://github.com/pepemoe2/Xv6-and-Unix-utilities.git
+10850c6a4bbfcc72eedf474c0138a624817b6748 10850c6a4bbfcc72eedf474c0138a624817b6748 hieu <dangthanhhieu2005@gmail.com> 1741150854 +0000	checkout: moving from main to submit-patch
+10850c6a4bbfcc72eedf474c0138a624817b6748 bb9f49fe266e8b7073a8bf6c2b9b0a3ce6c0480d hieu <dangthanhhieu2005@gmail.com> 1741150998 +0000	commit: Upload patch file
diff -ruN xv6-labs-2024-original/.git/logs/refs/heads/main xv6-labs-2024/.git/logs/refs/heads/main
--- xv6-labs-2024-original/.git/logs/refs/heads/main	1970-01-01 00:00:00.000000000 +0000
+++ xv6-labs-2024/.git/logs/refs/heads/main	2025-03-05 04:18:36.605011464 +0000
@@ -0,0 +1 @@
+0000000000000000000000000000000000000000 10850c6a4bbfcc72eedf474c0138a624817b6748 hieu <dangthanhhieu2005@gmail.com> 1741148316 +0000	clone: from https://github.com/pepemoe2/Xv6-and-Unix-utilities.git
diff -ruN xv6-labs-2024-original/.git/logs/refs/heads/submit-patch xv6-labs-2024/.git/logs/refs/heads/submit-patch
--- xv6-labs-2024-original/.git/logs/refs/heads/submit-patch	1970-01-01 00:00:00.000000000 +0000
+++ xv6-labs-2024/.git/logs/refs/heads/submit-patch	2025-03-05 05:03:18.027628074 +0000
@@ -0,0 +1,2 @@
+0000000000000000000000000000000000000000 10850c6a4bbfcc72eedf474c0138a624817b6748 hieu <dangthanhhieu2005@gmail.com> 1741150854 +0000	branch: Created from HEAD
+10850c6a4bbfcc72eedf474c0138a624817b6748 bb9f49fe266e8b7073a8bf6c2b9b0a3ce6c0480d hieu <dangthanhhieu2005@gmail.com> 1741150998 +0000	commit: Upload patch file
diff -ruN xv6-labs-2024-original/.git/logs/refs/heads/util xv6-labs-2024/.git/logs/refs/heads/util
--- xv6-labs-2024-original/.git/logs/refs/heads/util	2025-03-05 04:50:37.509724875 +0000
+++ xv6-labs-2024/.git/logs/refs/heads/util	1970-01-01 00:00:00.000000000 +0000
@@ -1 +0,0 @@
-0000000000000000000000000000000000000000 79e8024d61c3dd92ccf064fc67bb99cb999f70ab hieu <dangthanhhieu2005@gmail.com> 1741150237 +0000	clone: from git://g.csail.mit.edu/xv6-labs-2024
diff -ruN xv6-labs-2024-original/.git/logs/refs/remotes/origin/HEAD xv6-labs-2024/.git/logs/refs/remotes/origin/HEAD
--- xv6-labs-2024-original/.git/logs/refs/remotes/origin/HEAD	2025-03-05 04:50:37.509724875 +0000
+++ xv6-labs-2024/.git/logs/refs/remotes/origin/HEAD	2025-03-05 04:18:36.605011464 +0000
@@ -1 +1 @@
-0000000000000000000000000000000000000000 79e8024d61c3dd92ccf064fc67bb99cb999f70ab hieu <dangthanhhieu2005@gmail.com> 1741150237 +0000	clone: from git://g.csail.mit.edu/xv6-labs-2024
+0000000000000000000000000000000000000000 10850c6a4bbfcc72eedf474c0138a624817b6748 hieu <dangthanhhieu2005@gmail.com> 1741148316 +0000	clone: from https://github.com/pepemoe2/Xv6-and-Unix-utilities.git
diff -ruN xv6-labs-2024-original/.git/logs/refs/remotes/origin/submit-patch xv6-labs-2024/.git/logs/refs/remotes/origin/submit-patch
--- xv6-labs-2024-original/.git/logs/refs/remotes/origin/submit-patch	1970-01-01 00:00:00.000000000 +0000
+++ xv6-labs-2024/.git/logs/refs/remotes/origin/submit-patch	2025-03-05 05:03:42.106743709 +0000
@@ -0,0 +1 @@
+0000000000000000000000000000000000000000 bb9f49fe266e8b7073a8bf6c2b9b0a3ce6c0480d hieu <dangthanhhieu2005@gmail.com> 1741151022 +0000	update by push
Binary files xv6-labs-2024-original/.git/objects/6a/f8ddbf40029ec77d004476e3d95032b8e55112 and xv6-labs-2024/.git/objects/6a/f8ddbf40029ec77d004476e3d95032b8e55112 differ
diff -ruN xv6-labs-2024-original/.git/objects/bb/9f49fe266e8b7073a8bf6c2b9b0a3ce6c0480d xv6-labs-2024/.git/objects/bb/9f49fe266e8b7073a8bf6c2b9b0a3ce6c0480d
--- xv6-labs-2024-original/.git/objects/bb/9f49fe266e8b7073a8bf6c2b9b0a3ce6c0480d	1970-01-01 00:00:00.000000000 +0000
+++ xv6-labs-2024/.git/objects/bb/9f49fe266e8b7073a8bf6c2b9b0a3ce6c0480d	2025-03-05 05:03:18.027628074 +0000
@@ -0,0 +1,2 @@
+xùéK
+√0ªˆ)¥/Ÿë?ÅRzâ@∂Â8êƒ!8˜ozÖæ›º‘÷uÓ`∫ıCóês,ÑhFIﬁgD"Ôd»£≈¡ƒ ÷jm‘Œál4ã…1≈XRÚF$ÚîPÅù°†}tûÇ‚≥◊v@ùÂÑgÊmÍï∑˙CÉhﬂ” ÛÚHm}Åˆ§µ≈qp«kÍ≤◊«.ˇ’Í≥/ç3Ï‹SÖ2/¢æΩêHÈ
\ No newline at end of file
Binary files xv6-labs-2024-original/.git/objects/pack/pack-8637e08fd73ae66e5885db13e38fb370f45e5819.idx and xv6-labs-2024/.git/objects/pack/pack-8637e08fd73ae66e5885db13e38fb370f45e5819.idx differ
Binary files xv6-labs-2024-original/.git/objects/pack/pack-8637e08fd73ae66e5885db13e38fb370f45e5819.pack and xv6-labs-2024/.git/objects/pack/pack-8637e08fd73ae66e5885db13e38fb370f45e5819.pack differ
Binary files xv6-labs-2024-original/.git/objects/pack/pack-8637e08fd73ae66e5885db13e38fb370f45e5819.rev and xv6-labs-2024/.git/objects/pack/pack-8637e08fd73ae66e5885db13e38fb370f45e5819.rev differ
Binary files xv6-labs-2024-original/.git/objects/pack/pack-ad072c7bb251972be9d617877966c8b64c78e810.idx and xv6-labs-2024/.git/objects/pack/pack-ad072c7bb251972be9d617877966c8b64c78e810.idx differ
Binary files xv6-labs-2024-original/.git/objects/pack/pack-ad072c7bb251972be9d617877966c8b64c78e810.pack and xv6-labs-2024/.git/objects/pack/pack-ad072c7bb251972be9d617877966c8b64c78e810.pack differ
Binary files xv6-labs-2024-original/.git/objects/pack/pack-ad072c7bb251972be9d617877966c8b64c78e810.rev and xv6-labs-2024/.git/objects/pack/pack-ad072c7bb251972be9d617877966c8b64c78e810.rev differ
diff -ruN xv6-labs-2024-original/.git/packed-refs xv6-labs-2024/.git/packed-refs
--- xv6-labs-2024-original/.git/packed-refs	2025-03-05 04:50:37.499677470 +0000
+++ xv6-labs-2024/.git/packed-refs	2025-03-05 04:18:36.605011464 +0000
@@ -1,11 +1,2 @@
 # pack-refs with: peeled fully-peeled sorted 
-19fa72d7dccf193c7e09789db708443736c2954c refs/remotes/origin/cow
-408565dc36c7595de3e68284a3789c081901b88f refs/remotes/origin/fs
-fc27289d78a415ed4e4264a80b88c8496db70eef refs/remotes/origin/lock
-6dd1443e74895a3953d837106392a9ad538fbab2 refs/remotes/origin/mmap
-0b94a6a45fc79ad87112d16622bb5f2f130c893b refs/remotes/origin/net
-db30f8d9f46732d926995fb97a2ea0362f0654ee refs/remotes/origin/pgtbl
-de247db5e6384b138f270e0a7c745989b5a9c23b refs/remotes/origin/riscv
-d5b09ff4571e07f6d996fdf7ce1533afc19a6978 refs/remotes/origin/syscall
-814d126edf03b5498dbc7e0796190b938837a851 refs/remotes/origin/traps
-79e8024d61c3dd92ccf064fc67bb99cb999f70ab refs/remotes/origin/util
+10850c6a4bbfcc72eedf474c0138a624817b6748 refs/remotes/origin/main
diff -ruN xv6-labs-2024-original/.git/refs/heads/main xv6-labs-2024/.git/refs/heads/main
--- xv6-labs-2024-original/.git/refs/heads/main	1970-01-01 00:00:00.000000000 +0000
+++ xv6-labs-2024/.git/refs/heads/main	2025-03-05 04:18:36.605011464 +0000
@@ -0,0 +1 @@
+10850c6a4bbfcc72eedf474c0138a624817b6748
diff -ruN xv6-labs-2024-original/.git/refs/heads/submit-patch xv6-labs-2024/.git/refs/heads/submit-patch
--- xv6-labs-2024-original/.git/refs/heads/submit-patch	1970-01-01 00:00:00.000000000 +0000
+++ xv6-labs-2024/.git/refs/heads/submit-patch	2025-03-05 05:03:18.027628074 +0000
@@ -0,0 +1 @@
+bb9f49fe266e8b7073a8bf6c2b9b0a3ce6c0480d
diff -ruN xv6-labs-2024-original/.git/refs/heads/util xv6-labs-2024/.git/refs/heads/util
--- xv6-labs-2024-original/.git/refs/heads/util	2025-03-05 04:50:37.509724875 +0000
+++ xv6-labs-2024/.git/refs/heads/util	1970-01-01 00:00:00.000000000 +0000
@@ -1 +0,0 @@
-79e8024d61c3dd92ccf064fc67bb99cb999f70ab
diff -ruN xv6-labs-2024-original/.git/refs/remotes/origin/HEAD xv6-labs-2024/.git/refs/remotes/origin/HEAD
--- xv6-labs-2024-original/.git/refs/remotes/origin/HEAD	2025-03-05 04:50:37.509724875 +0000
+++ xv6-labs-2024/.git/refs/remotes/origin/HEAD	2025-03-05 04:18:36.605011464 +0000
@@ -1 +1 @@
-ref: refs/remotes/origin/util
+ref: refs/remotes/origin/main
diff -ruN xv6-labs-2024-original/.git/refs/remotes/origin/submit-patch xv6-labs-2024/.git/refs/remotes/origin/submit-patch
--- xv6-labs-2024-original/.git/refs/remotes/origin/submit-patch	1970-01-01 00:00:00.000000000 +0000
+++ xv6-labs-2024/.git/refs/remotes/origin/submit-patch	2025-03-05 05:03:42.106743709 +0000
@@ -0,0 +1 @@
+bb9f49fe266e8b7073a8bf6c2b9b0a3ce6c0480d
diff -ruN xv6-labs-2024-original/Makefile xv6-labs-2024/Makefile
--- xv6-labs-2024-original/Makefile	2025-03-05 04:50:37.509724875 +0000
+++ xv6-labs-2024/Makefile	2025-03-05 04:18:36.605011464 +0000
@@ -194,8 +194,10 @@
 	$U/_grind\
 	$U/_wc\
 	$U/_zombie\
-
-
+	$U/_pingpong\
+	$U/_primes\
+	$U/_find\
+	$U/_xargs\
 
 
 ifeq ($(LAB),syscall)
@@ -223,7 +225,8 @@
 
 ifeq ($(LAB),cow)
 UPROGS += \
-	$U/_cowtest
+	$U/
+_cowtest
 endif
 
 ifeq ($(LAB),thread)
diff -ruN "xv6-labs-2024-original/gradelib - Copy.py" "xv6-labs-2024/gradelib - Copy.py"
--- "xv6-labs-2024-original/gradelib - Copy.py"	1970-01-01 00:00:00.000000000 +0000
+++ "xv6-labs-2024/gradelib - Copy.py"	2025-03-05 04:18:36.605011464 +0000
@@ -0,0 +1,628 @@
+from __future__ import print_function
+
+import sys, os, re, time, socket, select, subprocess, errno, shutil, random, string, json
+from subprocess import check_call, Popen
+from optparse import OptionParser
+
+__all__ = []
+
+##################################################################
+# Test structure
+#
+
+__all__ += ["test", "end_part", "run_tests", "get_current_test"]
+
+TESTS = []
+TOTAL = POSSIBLE = 0
+PART_TOTAL = PART_POSSIBLE = 0
+CURRENT_TEST = None
+GRADES = {}
+
+def test(points, title=None, parent=None):
+    """Decorator for declaring test functions.  If title is None, the
+    title of the test will be derived from the function name by
+    stripping the leading "test_" and replacing underscores with
+    spaces."""
+
+    def register_test(fn, title=title):
+        if not title:
+            assert fn.__name__.startswith("test_")
+            title = fn.__name__[5:].replace("_", " ")
+        if parent:
+            title = "  " + title
+
+        def run_test():
+            global TOTAL, POSSIBLE, CURRENT_TEST, GRADES
+
+            # Handle test dependencies
+            if run_test.complete:
+                return run_test.ok
+            run_test.complete = True
+            parent_failed = False
+            if parent:
+                parent_failed = not parent()
+
+            # Run the test
+            fail = None
+            start = time.time()
+            CURRENT_TEST = run_test
+            sys.stdout.write("== Test %s == " % title)
+            if parent:
+                sys.stdout.write("\n")
+            sys.stdout.flush()
+            try:
+                if parent_failed:
+                    raise AssertionError('Parent failed: %s' % parent.__name__)
+                fn()
+            except AssertionError as e:
+                fail = str(e)
+
+            # Display and handle test result
+            POSSIBLE += points
+            if points:
+                print("%s: %s" % (title, \
+                    (color("red", "FAIL") if fail else color("green", "OK"))), end=' ')
+            if time.time() - start > 0.1:
+                print("(%.1fs)" % (time.time() - start), end=' ')
+            print()
+            if fail:
+                print("    %s" % fail.replace("\n", "\n    "))
+            else:
+                TOTAL += points
+            if points:
+                GRADES[title] = 0 if fail else points
+
+            for callback in run_test.on_finish:
+                callback(fail)
+            CURRENT_TEST = None
+
+            run_test.ok = not fail
+            return run_test.ok
+
+        # Record test metadata on the test wrapper function
+        run_test.__name__ = fn.__name__
+        run_test.title = title
+        run_test.complete = False
+        run_test.ok = False
+        run_test.on_finish = []
+        TESTS.append(run_test)
+        return run_test
+    return register_test
+
+def end_part(name):
+    def show_part():
+        global PART_TOTAL, PART_POSSIBLE
+        print("Part %s score: %d/%d" % \
+            (name, TOTAL - PART_TOTAL, POSSIBLE - PART_POSSIBLE))
+        print()
+        PART_TOTAL, PART_POSSIBLE = TOTAL, POSSIBLE
+    show_part.title = ""
+    TESTS.append(show_part)
+
+def write_results():
+    global options
+    if not options.results:
+        return
+    try:
+        with open(options.results, "w") as f:
+            f.write(json.dumps(GRADES))
+    except OSError as e:
+        print("Provided a bad results path. Error:", e)
+
+def run_tests():
+    """Set up for testing and run the registered test functions."""
+
+    # Handle command line
+    global options
+    parser = OptionParser(usage="usage: %prog [-v] [filters...]")
+    parser.add_option("-v", "--verbose", action="store_true",
+                      help="print commands")
+    parser.add_option("--color", choices=["never", "always", "auto"],
+                      default="auto", help="never, always, or auto")
+    parser.add_option("--results", help="results file path")
+    (options, args) = parser.parse_args()
+
+    # Start with a full build to catch build errors
+    make()
+
+    # Clean the file system if there is one
+    reset_fs()
+
+    # Run tests
+    limit = list(map(str.lower, args))
+    try:
+        for test in TESTS:
+            if not limit or any(l in test.title.lower() for l in limit):
+                test()
+        if not limit:
+            write_results()
+            print("Score: %d/%d" % (TOTAL, POSSIBLE))
+    except KeyboardInterrupt:
+        pass
+    if TOTAL < POSSIBLE:
+        sys.exit(1)
+
+def get_current_test():
+    if not CURRENT_TEST:
+        raise RuntimeError("No test is running")
+    return CURRENT_TEST
+
+##################################################################
+# Assertions
+#
+
+__all__ += ["assert_equal", "assert_lines_match"]
+
+def assert_equal(got, expect, msg=""):
+    if got == expect:
+        return
+    if msg:
+        msg += "\n"
+    raise AssertionError("%sgot:\n  %s\nexpected:\n  %s" %
+                         (msg, str(got).replace("\n", "\n  "),
+                          str(expect).replace("\n", "\n  ")))
+
+def assert_lines_match(text, *regexps, **kw):
+    """Assert that all of regexps match some line in text.  If a 'no'
+    keyword argument is given, it must be a list of regexps that must
+    *not* match any line in text."""
+
+    def assert_lines_match_kw(no=[]):
+        return no
+    no = assert_lines_match_kw(**kw)
+
+    # Check text against regexps
+    lines = text.splitlines()
+    good = set()
+    bad = set()
+    for i, line in enumerate(lines):
+        if any(re.match(r, line) for r in regexps):
+            good.add(i)
+            regexps = [r for r in regexps if not re.match(r, line)]
+        if any(re.match(r, line) for r in no):
+            bad.add(i)
+
+    if not regexps and not bad:
+        return
+
+    # We failed; construct an informative failure message
+    show = set()
+    for lineno in good.union(bad):
+        for offset in range(-2, 3):
+            show.add(lineno + offset)
+    if regexps:
+        show.update(n for n in range(len(lines) - 5, len(lines)))
+
+    msg = []
+    last = -1
+    for lineno in sorted(show):
+        if 0 <= lineno < len(lines):
+            if lineno != last + 1:
+                msg.append("...")
+            last = lineno
+            msg.append("%s %s" % (color("red", "BAD ") if lineno in bad else
+                                  color("green", "GOOD") if lineno in good
+                                  else "    ",
+                                  lines[lineno]))
+    if last != len(lines) - 1:
+        msg.append("...")
+    if bad:
+        msg.append("unexpected lines in output")
+    for r in regexps:
+        msg.append(color("red", "MISSING") + " '%s'" % r)
+    raise AssertionError("\n".join(msg))
+
+##################################################################
+# Utilities
+#
+
+__all__ += ["make", "maybe_unlink", "reset_fs", "color", "random_str", "check_time", "check_answers"]
+
+MAKE_TIMESTAMP = 0
+
+def pre_make():
+    """Delay prior to running make to ensure file mtimes change."""
+    while int(time.time()) == MAKE_TIMESTAMP:
+        time.sleep(0.1)
+
+def post_make():
+    """Record the time after make completes so that the next run of
+    make can be delayed if needed."""
+    global MAKE_TIMESTAMP
+    MAKE_TIMESTAMP = int(time.time())
+
+def make(*target):
+    pre_make()
+    if Popen(("make",) + target).wait():
+        sys.exit(1)
+    post_make()
+
+def show_command(cmd):
+    from pipes import quote
+    print("\n$", " ".join(map(quote, cmd)))
+
+def maybe_unlink(*paths):
+    for path in paths:
+        try:
+            os.unlink(path)
+        except EnvironmentError as e:
+            if e.errno != errno.ENOENT:
+                raise
+
+COLORS = {"default": "\033[0m", "red": "\033[31m", "green": "\033[32m"}
+
+def color(name, text):
+    if options.color == "always" or (options.color == "auto" and os.isatty(1)):
+        return COLORS[name] + text + COLORS["default"]
+    return text
+
+def reset_fs():
+    if os.path.exists("obj/fs/clean-fs.img"):
+        shutil.copyfile("obj/fs/clean-fs.img", "obj/fs/fs.img")
+
+def random_str(n=8):
+    letters = string.ascii_letters + string.digits
+    return ''.join(random.choice(letters) for _ in range(n))
+
+def check_time():
+    try:
+        print("")
+        with open('time.txt') as f:
+            d = f.read().strip()
+            if not re.match(r'^\d+$', d):
+                raise AssertionError('time.txt does not contain a single integer (number of hours spent on the lab)')
+    except IOError:
+        raise AssertionError('Cannot read time.txt')
+
+def check_answers(file, n=10):
+    try:
+        print("")
+        with open(file) as f:
+            d = f.read().strip()
+            if len(d) < n:
+                raise AssertionError('%s does not seem to contain enough text' % file)
+    except IOError:
+        raise AssertionError('Cannot read %s' % file)
+
+
+##################################################################
+# Controllers
+#
+
+__all__ += ["QEMU", "GDBClient"]
+
+class QEMU(object):
+    _GDBPORT = None
+
+    def __init__(self, *make_args):
+        # Check that QEMU is not currently running
+        try:
+            GDBClient(self.get_gdb_port(), timeout=0).close()
+        except socket.error:
+            pass
+        else:
+            print("""\
+GDB stub found on port %d.
+QEMU appears to already be running.  Please exit it if possible or use
+'killall qemu' or 'killall qemu.real'.""" % self.get_gdb_port(), file=sys.stderr)
+            sys.exit(1)
+
+        if options.verbose:
+            show_command(("make",) + make_args)
+        cmd = ("make", "-s", "--no-print-directory") + make_args
+        self.proc = Popen(cmd, stdout=subprocess.PIPE,
+                          stderr=subprocess.STDOUT,
+                          stdin=subprocess.PIPE)
+        # Accumulated output as a string
+        self.output = ""
+        # Accumulated output as a bytearray
+        self.outbytes = bytearray()
+        self.on_output = []
+
+    @staticmethod
+    def get_gdb_port():
+        if QEMU._GDBPORT is None:
+            p = Popen(["make", "-s", "--no-print-directory", "print-gdbport"],
+                      stdout=subprocess.PIPE)
+            (out, _) = p.communicate()
+            if p.returncode:
+                raise RuntimeError(
+                    "Failed to get gdbport: make exited with %d" %
+                    p.returncode)
+            QEMU._GDBPORT = int(out)
+        return QEMU._GDBPORT
+
+    def fileno(self):
+        if self.proc:
+            return self.proc.stdout.fileno()
+
+    def handle_read(self):
+        buf = os.read(self.proc.stdout.fileno(), 4096)
+        self.outbytes.extend(buf)
+        self.output = self.outbytes.decode("utf-8", "replace")
+        for callback in self.on_output:
+            callback(buf)
+        if buf == b"":
+            self.wait()
+            return
+
+    def write(self, buf):
+        if isinstance(buf, str):
+            buf = buf.encode('utf-8')
+        self.proc.stdin.write(buf)
+        self.proc.stdin.flush()
+
+    def wait(self):
+        if self.proc:
+            self.proc.wait()
+            self.proc = None
+
+    def kill(self):
+        if self.proc:
+            self.proc.terminate()
+
+class GDBClient(object):
+    def __init__(self, port, timeout=15):
+        start = time.time()
+        while True:
+            self.sock = socket.socket()
+            try:
+                self.sock.settimeout(1)
+                self.sock.connect(("localhost", port))
+                break
+            except socket.error:
+                if time.time() >= start + timeout:
+                    raise
+        self.__buf = ""
+
+    def fileno(self):
+        if self.sock:
+            return self.sock.fileno()
+
+    def handle_read(self):
+        try:
+            data = self.sock.recv(4096).decode("ascii", "replace")
+        except socket.error:
+            data = ""
+        if data == "":
+            self.sock.close()
+            self.sock = None
+            return
+        self.__buf += data
+
+        while True:
+            m = re.search(r"\$([^#]*)#[0-9a-zA-Z]{2}", self.__buf)
+            if not m:
+                break
+            pkt = m.group(1)
+            self.__buf = self.__buf[m.end():]
+
+            if pkt.startswith("T05"):
+                # Breakpoint
+                raise TerminateTest
+
+    def __send(self, cmd):
+        packet = "$%s#%02x" % (cmd, sum(map(ord, cmd)) % 256)
+        self.sock.sendall(packet.encode("ascii"))
+
+    def __send_break(self):
+        self.sock.sendall(b"\x03")
+
+    def close(self):
+        if self.sock:
+            self.sock.close()
+            self.sock = None
+
+    def cont(self):
+        self.__send("c")
+
+    def breakpoint(self, addr):
+        self.__send("Z1,%x,1" % addr)
+
+
+##################################################################
+# QEMU test runner
+#
+
+__all__ += ["TerminateTest", "Runner"]
+
+class TerminateTest(Exception):
+    pass
+
+class Runner():
+    def __init__(self, *default_monitors):
+        self.__default_monitors = default_monitors
+
+    def run_qemu(self, *monitors, **kw):
+        """Run a QEMU-based test.  monitors should functions that will
+        be called with this Runner instance once QEMU and GDB are
+        started.  Typically, they should register callbacks that throw
+        TerminateTest when stop events occur.  The target_base
+        argument gives the make target to run.  The make_args argument
+        should be a list of additional arguments to pass to make.  The
+        timeout argument bounds how long to run before returning."""
+
+        def run_qemu_kw(target_base="qemu", make_args=[], timeout=30):
+            return target_base, make_args, timeout
+        target_base, make_args, timeout = run_qemu_kw(**kw)
+
+        # Start QEMU
+        pre_make()
+        self.qemu = QEMU(target_base + "-gdb", *make_args)
+        self.gdb = None
+
+        try:
+            # Wait for QEMU to start or make to fail.  This will set
+            # self.gdb if QEMU starts.
+            self.qemu.on_output = [self.__monitor_start]
+            self.__react([self.qemu], timeout=90)
+            self.qemu.on_output = []
+            if self.gdb is None:
+                print("Failed to connect to QEMU; output:")
+                print(self.qemu.output)
+                sys.exit(1)
+            post_make()
+
+            # QEMU and GDB are up
+            self.reactors = [self.qemu, self.gdb]
+
+            # Start monitoring
+            for m in self.__default_monitors + monitors:
+                m(self)
+
+            # Run and react
+            self.gdb.cont()
+            self.__react(self.reactors, timeout)
+        finally:
+            # Shutdown QEMU
+            try:
+                if self.gdb is None:
+                    sys.exit(1)
+                self.qemu.kill()
+                self.__react(self.reactors, 5)
+                self.gdb.close()
+                self.qemu.wait()
+            except:
+                print("""\
+Failed to shutdown QEMU.  You might need to 'killall qemu' or
+'killall qemu.real'.
+""")
+                raise
+
+    def __monitor_start(self, output):
+        if b"\n" in output:
+            try:
+                self.gdb = GDBClient(self.qemu.get_gdb_port(), timeout=2)
+                raise TerminateTest
+            except socket.error:
+                pass
+        if not len(output):
+            raise TerminateTest
+
+    def __react(self, reactors, timeout):
+        deadline = time.time() + timeout
+        try:
+            while True:
+                timeleft = deadline - time.time()
+                if timeleft < 0:
+                    sys.stdout.write("Timeout! ")
+                    sys.stdout.flush()
+                    return
+
+                rset = [r for r in reactors if r.fileno() is not None]
+                if not rset:
+                    return
+
+                rset, _, _ = select.select(rset, [], [], timeleft)
+                for reactor in rset:
+                    reactor.handle_read()
+        except TerminateTest:
+            pass
+
+    def user_test(self, binary, *monitors, **kw):
+        """Run a user test using the specified binary.  Monitors and
+        keyword arguments are as for run_qemu.  This runs on a disk
+        snapshot unless the keyword argument 'snapshot' is False."""
+
+        maybe_unlink("obj/kern/init.o", "obj/kern/kernel")
+        if kw.pop("snapshot", True):
+            kw.setdefault("make_args", []).append("QEMUEXTRA+=-snapshot")
+        self.run_qemu(target_base="run-%s" % binary, *monitors, **kw)
+
+    def match(self, *args, **kwargs):
+        """Shortcut to call assert_lines_match on the most recent QEMU
+        output."""
+
+        assert_lines_match(self.qemu.output, *args, **kwargs)
+
+##################################################################
+# Monitors
+#
+
+__all__ += ["save", "stop_breakpoint", "call_on_line", "stop_on_line", "shell_script"]
+
+def save(path):
+    """Return a monitor that writes QEMU's output to path.  If the
+    test fails, copy the output to path.test-name."""
+
+    def setup_save(runner):
+        f.seek(0)
+        f.truncate()
+        runner.qemu.on_output.append(f.write)
+        get_current_test().on_finish.append(save_on_finish)
+
+    def save_on_finish(fail):
+        f.flush()
+        save_path = path + "." + get_current_test().__name__[5:]
+        if fail:
+            shutil.copyfile(path, save_path)
+            print("    QEMU output saved to %s" % save_path)
+        elif os.path.exists(save_path):
+            os.unlink(save_path)
+            print("    (Old %s failure log removed)" % save_path)
+
+    f = open(path, "wb")
+    return setup_save
+
+def stop_breakpoint(addr):
+    """Returns a monitor that stops when addr is reached.  addr may be
+    a number or the name of a symbol."""
+
+    def setup_breakpoint(runner):
+        if isinstance(addr, str):
+            addrs = [int(sym[:16], 16) for sym in open("kernel/kernel.sym")
+                     if sym[17:].strip() == addr]
+            assert len(addrs), "Symbol %s not found" % addr
+            runner.gdb.breakpoint(addrs[0])
+        else:
+            runner.gdb.breakpoint(addr)
+    return setup_breakpoint
+
+def call_on_line(regexp, callback):
+    """Returns a monitor that calls 'callback' when QEMU prints a line
+    matching 'regexp'."""
+
+    def setup_call_on_line(runner):
+        buf = bytearray()
+        def handle_output(output):
+            buf.extend(output)
+            while b"\n" in buf:
+                line, buf[:] = buf.split(b"\n", 1)
+                line = line.decode("utf-8", "replace")
+                if re.match(regexp, line):
+                    callback(line)
+        runner.qemu.on_output.append(handle_output)
+    return setup_call_on_line
+
+def stop_on_line(regexp):
+    """Returns a monitor that stops when QEMU prints a line matching
+    'regexp'."""
+
+    def stop(line):
+        raise TerminateTest
+    return call_on_line(regexp, stop)
+
+def shell_script(script, terminate_match=None):
+    """Returns a monitor that plays the script, and stops when the script is
+    done executing."""
+
+    def setup_call_on_line(runner):
+        class context:
+            n = 0
+            buf = bytearray()
+        def handle_output(output):
+            context.buf.extend(output)
+            if terminate_match is not None:
+                if re.match(terminate_match, context.buf.decode('utf-8', 'replace')):
+                    raise TerminateTest
+            if b'$ ' in context.buf:
+                context.buf = bytearray()
+                if context.n < len(script):
+                    runner.qemu.write(script[context.n])
+                    runner.qemu.write('\n')
+                    context.n += 1
+                else:
+                    if terminate_match is None:
+                        raise TerminateTest
+        runner.qemu.on_output.append(handle_output)
+    return setup_call_on_line
diff -ruN xv6-labs-2024-original/user/find.c xv6-labs-2024/user/find.c
--- xv6-labs-2024-original/user/find.c	1970-01-01 00:00:00.000000000 +0000
+++ xv6-labs-2024/user/find.c	2025-03-05 04:18:36.605011464 +0000
@@ -0,0 +1,67 @@
+#include "kernel/types.h"
+#include "kernel/stat.h"
+#include "user/user.h"
+#include "kernel/fs.h"
+#include "kernel/fcntl.h"
+char * get_filename(char* path)
+{
+    char* p;
+    for(p= path + strlen(path); p >= path && *p != '/'; p-- );
+    return p + 1;
+}
+void search_file_recursive(char *dir_path, char *target_name)
+{
+    char buf[512], *p;
+    int fd;
+    struct dirent de;
+    struct stat st;
+
+    if (!strcmp(get_filename(dir_path), target_name))
+    {
+        printf("%s\n", dir_path);
+    }
+    if((fd = open(dir_path, O_RDONLY)) < 0)
+    {
+        fprintf(2, "find: cannot open %s\n", dir_path);
+        return;
+    }
+
+    if(fstat(fd,&st) < 0)
+    {
+        fprintf(2, "find: cannot stat %s\n", dir_path);
+        close(fd);
+        return;
+    }
+    if(st.type != T_DIR)
+    {
+        close(fd);
+        return;
+    }
+    memset(buf, 0, sizeof(buf));  // X√≥a b·ªô nh·ªõ tr∆∞·ªõc khi d√πng
+    strcpy(buf, dir_path);
+    p = buf + strlen(buf);
+    *p++ = '/';
+
+    while(read(fd, &de, sizeof(de)) == sizeof(de))
+    {
+        if(de.inum == 0) continue;
+
+        memmove(p, de.name, DIRSIZ);
+        p[DIRSIZ] = 0;  // ƒê·∫£m b·∫£o chu·ªói k·∫øt th√∫c b·∫±ng '\0'
+
+        if(!strcmp(de.name, ".") || !strcmp(de.name, "..")) continue;
+
+        search_file_recursive(buf, target_name);
+    }
+    close(fd);
+}
+int main (int argc, char* argv[])
+{
+    if(argc < 3){
+        fprintf(2,"usage: find path filename\n"); // h∆∞·ªõng d·∫´n s·ª≠ d·ª•ng
+        exit(1);
+    }
+    
+    search_file_recursive(argv[1],argv[2]);
+    exit(0);
+}
\ No newline at end of file
diff -ruN xv6-labs-2024-original/user/pingpong.c xv6-labs-2024/user/pingpong.c
--- xv6-labs-2024-original/user/pingpong.c	1970-01-01 00:00:00.000000000 +0000
+++ xv6-labs-2024/user/pingpong.c	2025-03-05 04:18:36.605011464 +0000
@@ -0,0 +1,45 @@
+#include "kernel/types.h"
+#include "kernel/stat.h"
+#include "user/user.h"
+int main(int argc, char *argv[])
+{
+    int p1[2], p2[2];
+    char recv_buf[5];
+
+    pipe(p1);//p1[0]: ƒë·∫ßu ƒë·ªçc c·ªßa cha , p1[1]: ƒë·∫ßu ghi c·ªßa cha
+    pipe(p2);//p2[0]: ƒë·∫ßu ƒë·ªçc c·ªßa con, p2[1]: ƒë·∫ßu ghi c·ªßa con
+    
+    int pid = fork();
+
+    if (pid < 0)
+    {
+        fprintf(2,"Fork failed\n");
+        exit(1);
+    }
+
+    if (pid == 0)
+    {
+        close(p1[1]);
+        close(p2[0]);
+        read(p1[0], recv_buf, 5);
+        printf("%d: received %s\n", getpid(), recv_buf);
+        
+        write(p2[1], "pong", 5);
+        close(p1[0]);
+        close(p2[1]);
+        exit(0);
+    }
+
+    else
+    {
+        close(p1[0]);
+        close(p2[1]);
+        write(p1[1], "ping",5);
+        
+        read(p2[0], &recv_buf,5);
+        printf("%d: received %s\n", getpid(), recv_buf);
+        close(p1[1]);
+        close(p2[0]);
+        exit(0);
+    }
+}
\ No newline at end of file
diff -ruN xv6-labs-2024-original/user/primes.c xv6-labs-2024/user/primes.c
--- xv6-labs-2024-original/user/primes.c	1970-01-01 00:00:00.000000000 +0000
+++ xv6-labs-2024/user/primes.c	2025-03-05 04:18:36.605011464 +0000
@@ -0,0 +1,97 @@
+#include "kernel/types.h"
+#include "kernel/stat.h"
+#include "user/user.h"
+
+void sieve(int) __attribute__((noreturn));
+
+void sieve(int read_fd) 
+{
+    int first, current;
+    int new_pipe[2];
+
+    if (read(read_fd, &first, sizeof(int)) == 0) 
+    {
+        close(read_fd);
+        exit(0);
+    }
+
+    printf("prime %d\n", first);
+
+    if (pipe(new_pipe) < 0) {
+        printf("Error: Pipe creation failed\n");
+        close(read_fd);
+        exit(1);
+    }
+
+    int child_pid = fork();
+    if (child_pid < 0) 
+    {
+        printf("Error: Fork failed\n");
+        close(read_fd);
+        close(new_pipe[0]);
+        close(new_pipe[1]);
+        exit(1);
+    } 
+    else if (child_pid == 0) 
+    { 
+        // Ti·∫øn tr√¨nh con
+        close(new_pipe[1]);
+        close(read_fd);
+        sieve(new_pipe[0]);
+        close(new_pipe[0]);
+        exit(0);
+    } 
+    else
+    {
+        // Ti·∫øn tr√¨nh cha
+        close(new_pipe[0]);
+
+        while (read(read_fd, &current, sizeof(int))) {
+            if (current % first != 0) {
+                write(new_pipe[1], &current, sizeof(int));
+            }
+        }
+        close(new_pipe[1]);
+        close(read_fd);
+        wait(0);
+    }
+
+    exit(0);
+}
+
+int main() {
+    int initial_pipe[2];
+
+    if (pipe(initial_pipe) < 0) 
+    {
+        printf("Error: Pipe creation failed\n");
+        exit(1);
+    }
+
+    int root_pid = fork();
+    if (root_pid < 0) 
+    {
+        printf("Error: Fork failed\n");
+        close(initial_pipe[0]);
+        close(initial_pipe[1]);
+        exit(1);
+    } 
+    else if (root_pid == 0) 
+    {
+        close(initial_pipe[1]);
+        sieve(initial_pipe[0]);
+        close(initial_pipe[0]);
+        exit(0);
+    } 
+    else {
+        close(initial_pipe[0]);
+
+        for (int num = 2; num <= 280; num++) {
+
+            write(initial_pipe[1], &num, sizeof(int));
+        }
+        close(initial_pipe[1]);
+        wait(0);
+    }
+    exit(0);
+}
diff -ruN xv6-labs-2024-original/user/xargs.c xv6-labs-2024/user/xargs.c
--- xv6-labs-2024-original/user/xargs.c	1970-01-01 00:00:00.000000000 +0000
+++ xv6-labs-2024/user/xargs.c	2025-03-05 04:18:36.605011464 +0000
@@ -0,0 +1,137 @@
+#include "kernel/types.h"
+#include "kernel/stat.h"
+#include "user/user.h"
+#include "kernel/param.h"
+
+#define MAX_LINE 512
+#define MAX_ARGS MAXARG
+
+int string_compare(char* s1, char* s2) {
+    while (*s1 && *s1 == *s2) {
+        s1++;
+        s2++;
+    }
+    return *s1 - *s2;
+}
+
+int string_to_int(char* s) {
+    int num = 0;
+    while (*s >= '0' && *s <= '9') {
+        num = num * 10 + (*s - '0');
+        s++;
+    }
+    return num;
+}
+
+int main(int argc, char* argv[]) {
+    char* command_args[MAX_ARGS];
+    int command_arg_count = 0;
+    int batch_size = 0;
+    int command_start_index = 1;
+
+    if (argc < 2) {
+        printf("Usage: xargs command [args...]\n");
+        exit(1);
+    }
+
+    if (argc >= 3 && string_compare(argv[1], "-n") == 0) {
+        batch_size = string_to_int(argv[2]);
+        if (batch_size <= 0) {
+            printf("xargs: invalid number: %s\n", argv[2]);
+            exit(1);
+        }
+        command_start_index = 3;
+    }
+
+    for (int i = 0; i < argc - command_start_index; i++) {
+        command_args[i] = argv[i + command_start_index];
+        command_arg_count++;
+    }
+
+    char input_line[MAX_LINE];
+    char character;
+    int input_length = 0;
+
+    while (1) {
+        input_length = 0;
+        int bytes_read;
+        while ((bytes_read = read(0, &character, 1)) > 0) {
+            if (character == '\n') break;
+            if (input_length < MAX_LINE - 1) {
+                input_line[input_length++] = character;
+            }
+        }
+        input_line[input_length] = '\0';
+
+        if (bytes_read == 0 && input_length == 0) {
+            break;
+        }
+        if (input_length == 0) continue;
+
+        char* token_start = input_line;
+        int token_index = 0;
+        char* tokens[MAX_ARGS];
+        int token_count = 0;
+
+        while (token_index < input_length) {
+            while (token_index < input_length && (input_line[token_index] == ' ' || input_line[token_index] == '\t')) {
+                input_line[token_index] = '\0';
+                token_index++;
+            }
+            if (token_index >= input_length) break;
+            token_start = input_line + token_index;
+            tokens[token_count++] = token_start;
+            while (token_index < input_length && input_line[token_index] != ' ' && input_line[token_index] != '\t') {
+                token_index++;
+            }
+        }
+
+        if (token_count == 0) continue;
+
+        if (batch_size > 0) {
+            for (int i = 0; i < token_count; i += batch_size) {
+                int pid = fork();
+                if (pid < 0) {
+                    printf("xargs: fork failed\n");
+                    exit(1);
+                }
+                if (pid == 0) {
+                    for (int j = 0; j < command_arg_count; j++) {
+                        command_args[j] = argv[j + command_start_index];
+                    }
+                    int tokens_to_add = (i + batch_size < token_count) ? batch_size : (token_count - i);
+                    for (int j = 0; j < tokens_to_add; j++) {
+                        command_args[command_arg_count + j] = tokens[i + j];
+                    }
+                    command_args[command_arg_count + tokens_to_add] = 0;
+                    exec(command_args[0], command_args);
+                    printf("xargs: exec %s failed\n", command_args[0]);
+                    exit(1);
+                } else {
+                    wait(0);
+                }
+            }
+        } else {
+            for (int i = 0; i < token_count; i++) {
+                if (command_arg_count + i < MAX_ARGS - 1) {
+                    command_args[command_arg_count + i] = tokens[i];
+                }
+            }
+            command_args[command_arg_count + token_count] = 0;
+            int pid = fork();
+            if (pid < 0) {
+                printf("xargs: fork failed\n");
+                exit(1);
+            }
+            if (pid == 0) {
+                exec(command_args[0], command_args);
+                printf("xargs: exec %s failed\n", command_args[0]);
+                exit(1);
+            } else {
+                wait(0);
+            }
+        }
+    }
+
+    exit(0);
+}
